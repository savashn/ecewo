# Memory Management

## Table of Contents

1. [Arena API](#arena-api)
2. [Usage](#usage)
    1. [Using Handler's Arena](#using-handlers-arena)
    2. [Using Custom Arena](#using-custom-arena)
    3. [Using Handler's Arena Out of The Handler](#using-handlers-arena-out-of-the-handler)
3. [Cleanup App Resources](#cleanup-app-resources)

## Arena API

ecewo has its own arena allocator, which is a customized version of [tsoding/arena](https://github.com/tsoding/arena). Here are the functions available:

```c
void *arena_alloc(Arena *a, size_t size_bytes);
void *arena_realloc(Arena *a, void *oldptr, size_t oldsz, size_t newsz);
char *arena_strdup(Arena *a, const char *cstr);
char *arena_sprintf(Arena *a, const char *format, ...);
void *arena_memdup(Arena *a, void *data, size_t size);
void *arena_memcpy(void *dest, const void *src, size_t n);
void arena_free(Arena *a);
```

## Usage

Every handler in ecewo has an arena. You can access them by `req->arena` or `res->arena`. Both of them point the same arena, so you can use either one.

The handler's arena is going to be freed when you send a response. But if you want to create a separate arena for reason (for fire-and-forget tasks for example), you are responsible to free it.

### Using Handler's Arena

```c
#include "ecewo.h"

void arena_example(Req *req, Res *res)
{
    // Allocate memory (automatically freed after response)
    char *buffer = arena_alloc(req->arena, 1024);
    
    // Duplicate string
    char *copy = arena_strdup(req->arena, "original string");
    
    // Formatted string allocation
    char *formatted = arena_sprintf(req->arena, "User %d has %s access", 
                                   123, "admin");
    
    // Memory duplication
    char data[] = "binary data";
    void *dup = arena_memdup(req->arena, data, sizeof(data));
    
    // Reallocation
    char *new_buffer = arena_realloc(req->arena, buffer, 1024, 2048);
    
    send_text(res, 200, formatted); // Send a response, arena will be freed automatically
}
```

### Using Custom Arena

```c
#include "ecewo.h"
#include <stdlib.h>

void custom_arena_example(void)
{
    // Create custom arena
    Arena *custom = calloc(1, sizeof(Arena));
    
    // Allocate from custom arena
    char *data1 = arena_strdup(custom, "Hello");
    char *data2 = arena_sprintf(custom, "Number: %d", 42);
    int *numbers = arena_alloc(custom, sizeof(int) * 100);
    
    // Use the data
    char *response = arena_sprintf(custom, "%s - %s", data1, data2);
    
    printf(response\n);
    
    // Clean up custom arena
    arena_free(custom);
    free(custom);
}
```

### Using Handler's Arena Out of The Handler

You may want to use the existing arena that handler provides in a custom function (see the [Workers Chapter](07.workers.md)). That's totally fine, but you must be careful while doing that. The handler's arena is designed to be freed automatically when a response has been sent. So if you want to use the handler's arena outside of the handler, you have to send a response to the client.

If you want to use the handler's arena outside of the handler, **DO NOT DO THIS:**

```c
typedef struct
{
    Arena *arena;
    int result;
} Context;

void handler(Req *req, Res *res)
{
    // Create context
    Context *ctx = arena_alloc(res->arena, sizeof(Context));
    ctx->arena = res->arena;
    ctx->result = 0;
    
    // Imagine a function call here that will use the Context
}
```

This will break your application, because you'll never be able to send a response. To send a response and free the handler's arena, pass the Res struct's itself to the context, not the Arena.

**DO THIS INSTEAD:**

```c
typedef struct
{
    Res *res;
    int result;
} Context;

void handler(Req *req, Res *res)
{
    // Create context
    Context *ctx = arena_alloc(res->arena, sizeof(Context));
    ctx->res = res;
    ctx->result = 0;
    
    // Imagine a function call here that will use the Context
}
```

See the [Workers Chapter](07.workers.md) for more advanced examples.

> [!NOTE]
> 
> It's totally fine to use dynamic memory allocation functions that `stdlib.h` provides, but it's strongly recommended to use the arena allocator that ecewo offers.

## Cleanup App Resources

ecewo provides `server_atexit()` for one last cleanup right before shutting down the server. We can use it for such cases like saving critical data, completing pending transactions, closing database connections, final logs, cleaning up caches etc.

```c
// main.c

#include "ecewo.h"
#include <stdio.h>

// User resources cleanup
void app_cleanup(void)
{
    db_close();
    redis_close();

    printf("App cleaned up\n");
}

int main(void)
{
    server_init();

    db_init();
    redis_init();

    // Register app_cleanup function
    // It's going to work right before shutdown
    server_atexit(app_cleanup);

    if (server_listen(3000) != 0)
    {
        fprintf(stderr, "Failed to start server\n");
        return 1;
    }

    server_run();
    return 0;
}
```

> [!IMPORTANT]
>
> Need to register `server_atexit()` right before `server_listen()`.

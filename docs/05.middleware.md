# Middleware

ecewo provides a middleware feature, which looks like Express.js. Let’s see how they work.

## Table of Contents

1. [Route Specific Middleware](#route-specific-middleware)
2. [Global Middleware](#global-middleware)
3. [Middleware Context](#middleware-context)
4. [Async Middleware](#async-middleware)

## Route Specific Middleware

```c
#include "ecewo.h"

void admin_only(Req *req, Res *res, Next next) {
  const char *role = get_header(req, "X-User-Role");

  if (!role || strcmp(role, "admin") != 0) {
    send_text(res, 403, "Admin access required");
    return;
  }
  
  // Continue to next middleware/handler
  next(req, res);
}

void validate_settings(Req *req, Res *res, Next next) {
  // Some validation process...
  // Continue to next middleware/handler
  next(req, res);
}

int main(void) {
  // Server setup...

  // Apply middleware to specific route
  get("/admin/users", admin_only, users_handler);
  post("/admin/settings", admin_only, validate_settings, settings_handler);
  
  // ... rest of setup
}

```

## Global Middleware

We have `use()` to define global middlewares. Let’s implement a simple logger in middlewares.c and apply it before every handler.

```c
#include "ecewo.h"
#include "stdio.h"

void auth_middleware(Req *req, Res *res, Next next) {
  const char *auth = get_header(req, "Authorization");
  
  if (!auth || strncmp(auth, "Bearer ", 7) != 0) {
    send_text(res, 401, "Unauthorized");
    return;
  }
  
  // Continue to next middleware/handler
  next(req, res);
}

void logging_middleware(Req *req, Res *res, Next next) {
  printf("%s %s\n", req->method, req->path);
  next(req, res);
}

int main(void) {
  // Server setup ...

  // Apply to all routes
  use(logging_middleware);
  use(auth_middleware);
  
  get("/protected", protected_handler);
  // ... rest of setup
}
```

## Middleware Context

There is a specific way to pass the data along the middleware chain: `get_context()` and `set_context()` functions. We can pass the data to the next middleware or to the handler using them.

```c
typedef struct
{
  char *user_id;
  char *role;
} user_ctx_t;

void context_middleware(Req *req, Res *res, Next next) {
  const char *token = get_header(req, "Authorization");
  
  // Allocate context from request arena
  user_ctx_t *ctx = arena_alloc(req->arena, sizeof(user_ctx_t));
  ctx->user_id = arena_strdup(req->arena, "user123");
  ctx->role = arena_strdup(req->arena, "admin");
  
  // Store context pointer in request
  set_context(req, "user_ctx", ctx);
  
  // Continue to next middleware
  next(req, res);
}

void protected_handler(Req *req, Res *res) {
  // Retrieve context from request
  user_ctx_t *ctx = (user_ctx_t *)get_context(req, "user_ctx");
  
  if (!ctx) {
    send_text(res, UNAUTHORIZED, "Unauthorized");
    return;
  }
  
  if (strcmp(ctx->user_id, "user123") != 0 ||
    strcmp(ctx->role, "admin") != 0) {
    send_text(res, FORBIDDEN, "Forbidden");
    return;
  }
  
  send_text(res, OK, "Success!");
}
```

### Important Notes

**Context Lifecycle:**
- Context data is stored in the request arena
- Automatically cleaned up after response is sent
- Valid throughout the entire middleware chain and handler

**Memory Management:**
- Always allocate context data from `req->arena`
- `set_context()` stores the pointer directly (no copy)
- All middleware and handlers share the same pointer

> [!NOTE]
>
> ecewo has its own arena allocator. So `arena_alloc()` and `arena_strdup()` functions are parts of it. See the [next chapter](docs/06.memory-management.md).

## Async Middleware

```c
#include "ecewo.h"

typedef struct
{
  Req *req,
  Res *res,
  Next next,
  const char *token;
} Ctx;

void auth_middleware(Req *req, Res *res, Next next) {
  const char *token = get_header(req, "Authorization");
  
  if (!token) {
    send_text(res, 401, "ERROR: No token");
    return;
  }
  
  auth_context_t *ctx = arena_alloc(req->arena, sizeof(auth_context_t));
  ctx->req = req;
  ctx->res = res;
  ctx->next = next;
  ctx->token = arena_strdup(req->arena, token);
  
  spawn(ctx, verify_token_work, verify_token_done);
  // Do not call next() here, async process continues
}

void verify_token_done(void *context) {
  auth_context_t *ctx = (auth_context_t *)context;
  
  if (ctx->valid) {
    set_context(ctx->req, "user_id", &ctx->user_id, sizeof(int));
    ctx->next(ctx->req, ctx->res);
  }
  else
  {
    send_text(ctx->res, 401, "ERROR: Invalid token");
  }
}
```

> [!NOTE]
>
> The `spawn()` function is for running longtime blocking operations. See the [Workers](./07.workers.md) chapter.
